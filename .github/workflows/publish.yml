name: Create Release Draft

on:
  workflow_dispatch:
    inputs:
      release_type:
        description: 'Type de release'
        required: true
        default: 'patch'
        type: choice
        options:
        - patch
        - minor
        - major

jobs:
  create-draft:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      actions: write
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20'
    
    - name: Install pnpm
      uses: pnpm/action-setup@v4
      with:
        version: latest
    
    - name: Get pnpm store directory
      shell: bash
      run: |
        echo "STORE_PATH=$(pnpm store path --silent)" >> $GITHUB_ENV
    
    - name: Setup pnpm cache
      uses: actions/cache@v4
      with:
        path: ${{ env.STORE_PATH }}
        key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}
        restore-keys: |
          ${{ runner.os }}-pnpm-store-
    
    - name: Install dependencies
      run: pnpm install --frozen-lockfile
    
    - name: Read current version
      id: current_version
      run: |
        CURRENT_VERSION=$(node -p "require('./package.json').version")
        echo "current_version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
        echo "Current version: $CURRENT_VERSION"
    
    - name: Calculate new version
      id: new_version
      run: |
        CURRENT_VERSION="${{ steps.current_version.outputs.current_version }}"
        RELEASE_TYPE="${{ github.event.inputs.release_type }}"
        
        IFS='.' read -ra VERSION_PARTS <<< "$CURRENT_VERSION"
        MAJOR="${VERSION_PARTS[0]}"
        MINOR="${VERSION_PARTS[1]}"
        PATCH="${VERSION_PARTS[2]}"
        
        case $RELEASE_TYPE in
          "major")
            NEW_MAJOR=$((MAJOR + 1))
            NEW_VERSION="${NEW_MAJOR}.0.0"
            ;;
          "minor")
            NEW_MINOR=$((MINOR + 1))
            NEW_VERSION="${MAJOR}.${NEW_MINOR}.0"
            ;;
          "patch")
            NEW_PATCH=$((PATCH + 1))
            NEW_VERSION="${MAJOR}.${MINOR}.${NEW_PATCH}"
            ;;
        esac
        
        # VÃ©rifier si la version existe dÃ©jÃ 
        if git tag -l | grep -q "v$NEW_VERSION"; then
          echo "âŒ Erreur: La version v$NEW_VERSION existe dÃ©jÃ "
          echo "Tags existants:"
          git tag -l | grep "v$NEW_VERSION" || echo "Aucun tag trouvÃ©"
          exit 1
        fi
        
        echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
        echo "New version: $NEW_VERSION"
    
    - name: Build project
      run: |
        pnpm run build:prod
        
        # VÃ©rifier que les fichiers de build existent
        if [ ! -f "./dist/index.mjs" ] || [ ! -f "./dist/index.cjs" ] || [ ! -f "./dist/index.d.ts" ]; then
          echo "âŒ Erreur: Les fichiers de build n'ont pas Ã©tÃ© crÃ©Ã©s"
          echo "Contenu du dossier dist:"
          ls -la ./dist/ || echo "Dossier dist n'existe pas"
          exit 1
        fi
        echo "âœ… Build rÃ©ussi, fichiers crÃ©Ã©s:"
        ls -la ./dist/
    
    - name: Run tests
      run: |
        pnpm run test:run
        
        if [ $? -ne 0 ]; then
          echo "âŒ Erreur: Les tests ont Ã©chouÃ©"
          exit 1
        fi
        echo "âœ… Tests rÃ©ussis"
    
    - name: Create tag
      run: |
        NEW_VERSION="${{ steps.new_version.outputs.new_version }}"
        
        # Configuration Git
        git config --local user.email "github-actions[bot]@users.noreply.github.com"
        git config --local user.name "github-actions[bot]"
        
        # VÃ©rifier si le tag existe dÃ©jÃ 
        if git tag -l | grep -q "v$NEW_VERSION"; then
          echo "âš ï¸  Le tag v$NEW_VERSION existe dÃ©jÃ , suppression..."
          git tag -d "v$NEW_VERSION" || true
          git push origin ":refs/tags/v$NEW_VERSION" || true
        fi
        
        # CrÃ©er le tag
        git tag -a "v$NEW_VERSION" -m "Release v$NEW_VERSION"
        
        # Push du tag
        echo "Pushing tag..."
        git push origin "v$NEW_VERSION" || {
          echo "âŒ Erreur lors du push du tag"
          git tag -l
          exit 1
        }
        
        echo "âœ… Tag crÃ©Ã© et poussÃ© avec succÃ¨s"
    
    - name: Generate changelog
      id: changelog
      run: |
        NEW_VERSION="${{ steps.new_version.outputs.new_version }}"
        PREVIOUS_TAG=$(git describe --tags --abbrev=0 HEAD~1 2>/dev/null || echo "")
        
        if [ -n "$PREVIOUS_TAG" ]; then
          CHANGELOG=$(git log --pretty=format:"- %s" $PREVIOUS_TAG..HEAD)
        else
          CHANGELOG=$(git log --pretty=format:"- %s" --reverse)
        fi
        
        echo "changelog<<EOF" >> $GITHUB_OUTPUT
        echo "$CHANGELOG" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT
    
    - name: Create Draft Release
      id: create_release
      run: |
        NEW_VERSION="${{ steps.new_version.outputs.new_version }}"
        
        # CrÃ©er la release draft via l'API GitHub
        echo "## ðŸš€ Release v$NEW_VERSION" > release_body.txt
        echo "" >> release_body.txt
        echo "### ðŸ“‹ Changelog" >> release_body.txt
        echo "${{ steps.changelog.outputs.changelog }}" >> release_body.txt
        echo "" >> release_body.txt
        echo "### ðŸ“¦ Installation" >> release_body.txt
        echo '```bash' >> release_body.txt
        echo 'npm install classigo' >> release_body.txt
        echo '```' >> release_body.txt
        echo "" >> release_body.txt
        echo '```bash' >> release_body.txt
        echo 'pnpm add classigo' >> release_body.txt
        echo '```' >> release_body.txt
        echo "" >> release_body.txt
        echo '```bash' >> release_body.txt
        echo 'yarn add classigo' >> release_body.txt
        echo '```' >> release_body.txt
        echo "" >> release_body.txt
        echo "### ðŸ”§ Utilisation" >> release_body.txt
        echo '```javascript' >> release_body.txt
        echo 'import classigo from "classigo";' >> release_body.txt
        echo '' >> release_body.txt
        echo '// Utilisation basique' >> release_body.txt
        echo 'const className = classigo("base", "active", "large");' >> release_body.txt
        echo '// RÃ©sultat: "base active large"' >> release_body.txt
        echo '```' >> release_body.txt
        echo "" >> release_body.txt
        echo "### ðŸ“ Notes" >> release_body.txt
        echo "- Version: $NEW_VERSION" >> release_body.txt
        echo "- Build testÃ© et validÃ©" >> release_body.txt
        echo "- Tests exÃ©cutÃ©s avec succÃ¨s" >> release_body.txt
        echo "- **Draft release - Ã€ valider avant publication**" >> release_body.txt
        
        RELEASE_BODY=$(cat release_body.txt)
        
        # CrÃ©er le JSON de la release
        echo '{' > release_data.json
        echo '  "tag_name": "v$NEW_VERSION",' >> release_data.json
        echo '  "name": "Release v$NEW_VERSION",' >> release_data.json
        echo '  "body": '$(echo "$RELEASE_BODY" | jq -R -s .)',' >> release_data.json
        echo '  "draft": true,' >> release_data.json
        echo '  "prerelease": false' >> release_data.json
        echo '}' >> release_data.json
        
        echo "Release data:"
        cat release_data.json
        
        RELEASE_RESPONSE=$(curl -s -X POST \
          -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
          -H "Accept: application/vnd.github.v3+json" \
          -H "Content-Type: application/json" \
          "https://api.github.com/repos/${{ github.repository }}/releases" \
          -d @release_data.json)
        
        echo "Release creation response: $RELEASE_RESPONSE"
        
        # VÃ©rifier si la crÃ©ation a rÃ©ussi
        RELEASE_ID=$(echo "$RELEASE_RESPONSE" | jq -r '.id')
        if [ "$RELEASE_ID" = "null" ] || [ -z "$RELEASE_ID" ]; then
          echo "âŒ Erreur lors de la crÃ©ation de la release"
          echo "Response: $RELEASE_RESPONSE"
          exit 1
        fi
        
        echo "âœ… Release draft crÃ©Ã©e avec succÃ¨s, ID: $RELEASE_ID"
        echo "release_id=$RELEASE_ID" >> $GITHUB_OUTPUT
    
    - name: Upload Release Assets
      run: |
        RELEASE_ID="${{ steps.create_release.outputs.release_id }}"
        UPLOAD_URL="https://uploads.github.com/repos/${{ github.repository }}/releases/$RELEASE_ID/assets"
        
        echo "ðŸ“¤ Upload des fichiers de build..."
        
        # Upload des fichiers principaux
        for file in index.mjs index.cjs index.d.ts index.umd.js; do
          if [ -f "./dist/$file" ]; then
            echo "ðŸ“¤ Upload de $file..."
            curl -s -X POST \
              -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              -H "Accept: application/vnd.github.v3+json" \
              -H "Content-Type: application/octet-stream" \
              --data-binary @./dist/$file \
              "$UPLOAD_URL?name=$file"
          fi
        done
        
        echo "âœ… Assets uploadÃ©s avec succÃ¨s"
    
    - name: Success message
      run: |
        NEW_VERSION="${{ steps.new_version.outputs.new_version }}"
        RELEASE_ID="${{ steps.create_release.outputs.release_id }}"
        echo "ðŸŽ‰ Release draft v$NEW_VERSION crÃ©Ã© avec succÃ¨s !"
        echo "ðŸ“¦ Assets uploadÃ©s"
        echo "ðŸ”— Release: https://github.com/${{ github.repository }}/releases/tag/v$NEW_VERSION"
        echo ""
        echo "ðŸ“‹ Prochaines Ã©tapes:"
        echo "1. VÃ©rifiez la release draft sur GitHub"
        echo "2. Si tout est OK, publiez la release"
        echo "3. Le workflow 'Publish to npm' se dÃ©clenchera automatiquement"
