name: Create Release Draft

on:
  workflow_dispatch:
    inputs:
      release_type:
        description: 'Type de release'
        required: true
        default: 'patch'
        type: choice
        options:
        - patch
        - minor
        - major

jobs:
  create-draft:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      actions: write
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20'
    
    - name: Install pnpm
      uses: pnpm/action-setup@v4
      with:
        version: latest
    
    - name: Get pnpm store directory
      shell: bash
      run: |
        echo "STORE_PATH=$(pnpm store path --silent)" >> $GITHUB_ENV
    
    - name: Setup pnpm cache
      uses: actions/cache@v4
      with:
        path: ${{ env.STORE_PATH }}
        key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}
        restore-keys: |
          ${{ runner.os }}-pnpm-store-
    
    - name: Install dependencies
      run: pnpm install --frozen-lockfile
    
    - name: Read current version
      id: current_version
      run: |
        CURRENT_VERSION=$(node -p "require('./package.json').version")
        echo "current_version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
        echo "Current version: $CURRENT_VERSION"
    
    - name: Calculate new version
      id: new_version
      run: |
        CURRENT_VERSION="${{ steps.current_version.outputs.current_version }}"
        RELEASE_TYPE="${{ github.event.inputs.release_type }}"
        
        IFS='.' read -ra VERSION_PARTS <<< "$CURRENT_VERSION"
        MAJOR="${VERSION_PARTS[0]}"
        MINOR="${VERSION_PARTS[1]}"
        PATCH="${VERSION_PARTS[2]}"
        
        case $RELEASE_TYPE in
          "major")
            NEW_MAJOR=$((MAJOR + 1))
            NEW_VERSION="${NEW_MAJOR}.0.0"
            ;;
          "minor")
            NEW_MINOR=$((MINOR + 1))
            NEW_VERSION="${MAJOR}.${NEW_MINOR}.0"
            ;;
          "patch")
            NEW_PATCH=$((PATCH + 1))
            NEW_VERSION="${MAJOR}.${MINOR}.${NEW_PATCH}"
            ;;
        esac
        
        # Vérifier si la version existe déjà
        if git tag -l | grep -q "v$NEW_VERSION"; then
          echo "❌ Erreur: La version v$NEW_VERSION existe déjà"
          echo "Tags existants:"
          git tag -l | grep "v$NEW_VERSION" || echo "Aucun tag trouvé"
          exit 1
        fi
        
        echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
        echo "New version: $NEW_VERSION"
    
    - name: Build project
      run: |
        pnpm run build:prod
        
        # Vérifier que les fichiers de build existent
        if [ ! -f "./dist/index.mjs" ] || [ ! -f "./dist/index.cjs" ] || [ ! -f "./dist/index.d.ts" ]; then
          echo "❌ Erreur: Les fichiers de build n'ont pas été créés"
          echo "Contenu du dossier dist:"
          ls -la ./dist/ || echo "Dossier dist n'existe pas"
          exit 1
        fi
        echo "✅ Build réussi, fichiers créés:"
        ls -la ./dist/
    
    - name: Run tests
      run: |
        pnpm run test:run
        
        if [ $? -ne 0 ]; then
          echo "❌ Erreur: Les tests ont échoué"
          exit 1
        fi
        echo "✅ Tests réussis"
    
    - name: Create tag
      run: |
        NEW_VERSION="${{ steps.new_version.outputs.new_version }}"
        
        # Configuration Git
        git config --local user.email "github-actions[bot]@users.noreply.github.com"
        git config --local user.name "github-actions[bot]"
        
        # Vérifier si le tag existe déjà
        if git tag -l | grep -q "v$NEW_VERSION"; then
          echo "⚠️  Le tag v$NEW_VERSION existe déjà, suppression..."
          git tag -d "v$NEW_VERSION" || true
          git push origin ":refs/tags/v$NEW_VERSION" || true
        fi
        
        # Créer le tag
        git tag -a "v$NEW_VERSION" -m "Release v$NEW_VERSION"
        
        # Push du tag
        echo "Pushing tag..."
        git push origin "v$NEW_VERSION" || {
          echo "❌ Erreur lors du push du tag"
          git tag -l
          exit 1
        }
        
        echo "✅ Tag créé et poussé avec succès"
    
    - name: Generate changelog
      id: changelog
      run: |
        NEW_VERSION="${{ steps.new_version.outputs.new_version }}"
        PREVIOUS_TAG=$(git describe --tags --abbrev=0 HEAD~1 2>/dev/null || echo "")
        
        if [ -n "$PREVIOUS_TAG" ]; then
          CHANGELOG=$(git log --pretty=format:"- %s" $PREVIOUS_TAG..HEAD)
        else
          CHANGELOG=$(git log --pretty=format:"- %s" --reverse)
        fi
        
        echo "changelog<<EOF" >> $GITHUB_OUTPUT
        echo "$CHANGELOG" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT
    
    - name: Create Draft Release
      id: create_release
      run: |
        NEW_VERSION="${{ steps.new_version.outputs.new_version }}"
        
        # Créer la release draft via l'API GitHub
        echo "## 🚀 Release v$NEW_VERSION" > release_body.txt
        echo "" >> release_body.txt
        echo "### 📋 Changelog" >> release_body.txt
        echo "${{ steps.changelog.outputs.changelog }}" >> release_body.txt
        echo "" >> release_body.txt
        echo "### 📦 Installation" >> release_body.txt
        echo '```bash' >> release_body.txt
        echo 'npm install classigo' >> release_body.txt
        echo '```' >> release_body.txt
        echo "" >> release_body.txt
        echo '```bash' >> release_body.txt
        echo 'pnpm add classigo' >> release_body.txt
        echo '```' >> release_body.txt
        echo "" >> release_body.txt
        echo '```bash' >> release_body.txt
        echo 'yarn add classigo' >> release_body.txt
        echo '```' >> release_body.txt
        echo "" >> release_body.txt
        echo "### 🔧 Utilisation" >> release_body.txt
        echo '```javascript' >> release_body.txt
        echo 'import classigo from "classigo";' >> release_body.txt
        echo '' >> release_body.txt
        echo '// Utilisation basique' >> release_body.txt
        echo 'const className = classigo("base", "active", "large");' >> release_body.txt
        echo '// Résultat: "base active large"' >> release_body.txt
        echo '```' >> release_body.txt
        echo "" >> release_body.txt
        echo "### 📝 Notes" >> release_body.txt
        echo "- Version: $NEW_VERSION" >> release_body.txt
        echo "- Build testé et validé" >> release_body.txt
        echo "- Tests exécutés avec succès" >> release_body.txt
        echo "- **Draft release - À valider avant publication**" >> release_body.txt
        
        RELEASE_BODY=$(cat release_body.txt)
        
        # Créer le JSON de la release
        echo '{' > release_data.json
        echo '  "tag_name": "v$NEW_VERSION",' >> release_data.json
        echo '  "name": "Release v$NEW_VERSION",' >> release_data.json
        echo '  "body": '$(echo "$RELEASE_BODY" | jq -R -s .)',' >> release_data.json
        echo '  "draft": true,' >> release_data.json
        echo '  "prerelease": false' >> release_data.json
        echo '}' >> release_data.json
        
        echo "Release data:"
        cat release_data.json
        
        RELEASE_RESPONSE=$(curl -s -X POST \
          -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
          -H "Accept: application/vnd.github.v3+json" \
          -H "Content-Type: application/json" \
          "https://api.github.com/repos/${{ github.repository }}/releases" \
          -d @release_data.json)
        
        echo "Release creation response: $RELEASE_RESPONSE"
        
        # Vérifier si la création a réussi
        RELEASE_ID=$(echo "$RELEASE_RESPONSE" | jq -r '.id')
        if [ "$RELEASE_ID" = "null" ] || [ -z "$RELEASE_ID" ]; then
          echo "❌ Erreur lors de la création de la release"
          echo "Response: $RELEASE_RESPONSE"
          exit 1
        fi
        
        echo "✅ Release draft créée avec succès, ID: $RELEASE_ID"
        echo "release_id=$RELEASE_ID" >> $GITHUB_OUTPUT
    
    - name: Upload Release Assets
      run: |
        RELEASE_ID="${{ steps.create_release.outputs.release_id }}"
        UPLOAD_URL="https://uploads.github.com/repos/${{ github.repository }}/releases/$RELEASE_ID/assets"
        
        echo "📤 Upload des fichiers de build..."
        
        # Upload des fichiers principaux
        for file in index.mjs index.cjs index.d.ts index.umd.js; do
          if [ -f "./dist/$file" ]; then
            echo "📤 Upload de $file..."
            curl -s -X POST \
              -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              -H "Accept: application/vnd.github.v3+json" \
              -H "Content-Type: application/octet-stream" \
              --data-binary @./dist/$file \
              "$UPLOAD_URL?name=$file"
          fi
        done
        
        echo "✅ Assets uploadés avec succès"
    
    - name: Success message
      run: |
        NEW_VERSION="${{ steps.new_version.outputs.new_version }}"
        RELEASE_ID="${{ steps.create_release.outputs.release_id }}"
        echo "🎉 Release draft v$NEW_VERSION créé avec succès !"
        echo "📦 Assets uploadés"
        echo "🔗 Release: https://github.com/${{ github.repository }}/releases/tag/v$NEW_VERSION"
        echo ""
        echo "📋 Prochaines étapes:"
        echo "1. Vérifiez la release draft sur GitHub"
        echo "2. Si tout est OK, publiez la release"
        echo "3. Le workflow 'Publish to npm' se déclenchera automatiquement"
