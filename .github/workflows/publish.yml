name: Create Release Draft

on:
  workflow_dispatch:
    inputs:
      release_type:
        description: 'Release type'
        required: true
        default: 'patch'
        type: choice
        options:
        - patch
        - minor
        - major

jobs:
  create-draft:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      actions: write
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20'
    
    - name: Install pnpm
      uses: pnpm/action-setup@v4
      with:
        version: latest
    
    - name: Get pnpm store directory
      shell: bash
      run: |
        echo "STORE_PATH=$(pnpm store path --silent)" >> $GITHUB_ENV
    
    - name: Setup pnpm cache
      uses: actions/cache@v4
      with:
        path: ${{ env.STORE_PATH }}
        key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}
        restore-keys: |
          ${{ runner.os }}-pnpm-store-
    
    - name: Install dependencies
      run: pnpm install --frozen-lockfile
    
    - name: Read current version
      id: current_version
      run: |
        CURRENT_VERSION=$(node -p "require('./package.json').version")
        echo "current_version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
        echo "Current version: $CURRENT_VERSION"
    
    - name: Calculate new version
      id: new_version
      run: |
        CURRENT_VERSION="${{ steps.current_version.outputs.current_version }}"
        RELEASE_TYPE="${{ github.event.inputs.release_type }}"
        
        IFS='.' read -ra VERSION_PARTS <<< "$CURRENT_VERSION"
        MAJOR="${VERSION_PARTS[0]}"
        MINOR="${VERSION_PARTS[1]}"
        PATCH="${VERSION_PARTS[2]}"
        
        case $RELEASE_TYPE in
          "major")
            NEW_MAJOR=$((MAJOR + 1))
            NEW_VERSION="${NEW_MAJOR}.0.0"
            ;;
          "minor")
            NEW_MINOR=$((MINOR + 1))
            NEW_VERSION="${MAJOR}.${NEW_MINOR}.0"
            ;;
          "patch")
            NEW_PATCH=$((PATCH + 1))
            NEW_VERSION="${MAJOR}.${MINOR}.${NEW_PATCH}"
            ;;
        esac
        
        # Check if version already exists
        if git tag -l | grep -q "v$NEW_VERSION"; then
          echo "âŒ Error: Version v$NEW_VERSION already exists"
          echo "Existing tags:"
          git tag -l | grep "v$NEW_VERSION" || echo "No tags found"
          exit 1
        fi
        
        echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
        echo "New version: $NEW_VERSION"
    
    - name: Build project
      run: |
        pnpm run build:prod
        
        # Check if build files exist
        if [ ! -f "./dist/index.mjs" ] || [ ! -f "./dist/index.cjs" ] || [ ! -f "./dist/index.d.ts" ]; then
          echo "âŒ Error: Build files were not created"
          echo "Dist folder content:"
          ls -la ./dist/ || echo "Dist folder does not exist"
          exit 1
        fi
        echo "âœ… Build successful, files created:"
        ls -la ./dist/
    
    - name: Run tests
      run: |
        pnpm run test:run
        
        if [ $? -ne 0 ]; then
          echo "âŒ Error: Tests failed"
          exit 1
        fi
        echo "âœ… Tests passed"
    
    - name: Create tag
      run: |
        NEW_VERSION="${{ steps.new_version.outputs.new_version }}"
        
        # Git configuration
        git config --local user.email "github-actions[bot]@users.noreply.github.com"
        git config --local user.name "github-actions[bot]"
        
        # Check if tag already exists
        if git tag -l | grep -q "v$NEW_VERSION"; then
          echo "âš ï¸  Tag v$NEW_VERSION already exists, removing..."
          git tag -d "v$NEW_VERSION" || true
          git push origin ":refs/tags/v$NEW_VERSION" || true
        fi
        
        # Create a temporary branch for the tag
        git checkout -b temp-release-branch
        
        # Update package.json version only on this branch
        node -e "
          const pkg = require('./package.json');
          pkg.version = '$NEW_VERSION';
          require('fs').writeFileSync('package.json', JSON.stringify(pkg, null, 2) + '\n');
        "
        
        # Commit the version change
        git add package.json
        git commit -m "Bump version to $NEW_VERSION [skip ci]"
        
        # Create tag from this branch
        git tag -a "v$NEW_VERSION" -m "Release v$NEW_VERSION"
        
        # Push tag
        echo "Pushing tag..."
        git push origin "v$NEW_VERSION" || {
          echo "âŒ Error pushing tag"
          git tag -l
          exit 1
        }
        
        # Clean up temporary branch
        git checkout main
        git branch -D temp-release-branch
        
        echo "âœ… Tag created and pushed successfully"
    
    - name: Generate changelog
      id: changelog
      run: |
        NEW_VERSION="${{ steps.new_version.outputs.new_version }}"
        PREVIOUS_TAG=$(git describe --tags --abbrev=0 HEAD~1 2>/dev/null || echo "")
        
        if [ -n "$PREVIOUS_TAG" ]; then
          CHANGELOG=$(git log --pretty=format:"- %s" $PREVIOUS_TAG..HEAD)
        else
          CHANGELOG=$(git log --pretty=format:"- %s" --reverse)
        fi
        
        echo "changelog<<EOF" >> $GITHUB_OUTPUT
        echo "$CHANGELOG" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT
    
    - name: Create Draft Release
      id: create_release
      run: |
        NEW_VERSION="${{ steps.new_version.outputs.new_version }}"
        
        # Create release draft via GitHub API
        echo "## ðŸš€ Release v$NEW_VERSION" > release_body.txt
        echo "" >> release_body.txt
        echo "### ðŸ“‹ Changelog" >> release_body.txt
        echo "${{ steps.changelog.outputs.changelog }}" >> release_body.txt
        echo "" >> release_body.txt
        echo "### ðŸ“¦ Installation" >> release_body.txt
        echo '```bash' >> release_body.txt
        echo 'npm install classigo' >> release_body.txt
        echo '```' >> release_body.txt
        echo "" >> release_body.txt
        echo '```bash' >> release_body.txt
        echo 'pnpm add classigo' >> release_body.txt
        echo '```' >> release_body.txt
        echo "" >> release_body.txt
        echo '```bash' >> release_body.txt
        echo 'yarn add classigo' >> release_body.txt
        echo '```' >> release_body.txt
        echo "" >> release_body.txt
        echo "### ðŸ”§ Usage" >> release_body.txt
        echo '```javascript' >> release_body.txt
        echo 'import classigo from "classigo";' >> release_body.txt
        echo '' >> release_body.txt
        echo '// Basic usage' >> release_body.txt
        echo 'const className = classigo("base", "active", "large");' >> release_body.txt
        echo '// Result: "base active large"' >> release_body.txt
        echo '```' >> release_body.txt
        echo "" >> release_body.txt
        echo "### ðŸ“ Notes" >> release_body.txt
        echo "- Version: $NEW_VERSION" >> release_body.txt
        echo "- Build tested and validated" >> release_body.txt
        echo "- Tests executed successfully" >> release_body.txt
        echo "- **Draft release - Review before publishing**" >> release_body.txt
        
        RELEASE_BODY=$(cat release_body.txt)
        
        # Create release JSON with variables replaced
        echo "{\"tag_name\":\"v$NEW_VERSION\",\"name\":\"Release v$NEW_VERSION\",\"body\":$(echo "$RELEASE_BODY" | jq -R -s .),\"draft\":true,\"prerelease\":false}" > release_data.json
        
        echo "Release data:"
        cat release_data.json
        
        RELEASE_RESPONSE=$(curl -s -X POST \
          -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
          -H "Accept: application/vnd.github.v3+json" \
          -H "Content-Type: application/json" \
          "https://api.github.com/repos/${{ github.repository }}/releases" \
          -d @release_data.json)
        
        echo "Release creation response: $RELEASE_RESPONSE"
        
        # Check if creation was successful
        RELEASE_ID=$(echo "$RELEASE_RESPONSE" | jq -r '.id')
        if [ "$RELEASE_ID" = "null" ] || [ -z "$RELEASE_ID" ]; then
          echo "âŒ Error creating release"
          echo "Response: $RELEASE_RESPONSE"
          exit 1
        fi
        
        echo "âœ… Release draft created successfully, ID: $RELEASE_ID"
        echo "release_id=$RELEASE_ID" >> $GITHUB_OUTPUT
    
    - name: Upload Release Assets
      run: |
        RELEASE_ID="${{ steps.create_release.outputs.release_id }}"
        UPLOAD_URL="https://uploads.github.com/repos/${{ github.repository }}/releases/$RELEASE_ID/assets"
        
        echo "ðŸ“¤ Uploading build files..."
        
        # Upload main files
        for file in index.mjs index.cjs index.d.ts index.umd.js; do
          if [ -f "./dist/$file" ]; then
            echo "ðŸ“¤ Uploading $file..."
            curl -s -X POST \
              -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              -H "Accept: application/vnd.github.v3+json" \
              -H "Content-Type: application/octet-stream" \
              --data-binary @./dist/$file \
              "$UPLOAD_URL?name=$file"
          fi
        done
        
        echo "âœ… Assets uploaded successfully"
    
    - name: Success message
      run: |
        NEW_VERSION="${{ steps.new_version.outputs.new_version }}"
        RELEASE_ID="${{ steps.create_release.outputs.release_id }}"
        echo "ðŸŽ‰ Release draft v$NEW_VERSION created successfully!"
        echo "ðŸ“¦ Assets uploaded"
        echo "ðŸ”— Release: https://github.com/${{ github.repository }}/releases/tag/v$NEW_VERSION"
        echo ""
        echo "ðŸ“‹ Next steps:"
        echo "1. Review the release draft on GitHub"
        echo "2. If everything looks good, publish the release"
        echo "3. The 'Publish to npm' workflow will trigger automatically"
